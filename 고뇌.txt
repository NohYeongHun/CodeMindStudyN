ex) 3 5 2 7 인경우
3은 7 2 5 3 순으로 비교를 하고
오큰수 인경우 obig에 넣어주고
오큰수가 없는 경우 -1을 obig에 넣어준다.

이 문제는 전형적인 스택 문제 중에 하나입니다. 
힌트를 하나 드리자면, 
원소를 오른쪽부터 하나씩 볼 때,
 arr[i] >= arr[i + 1]이라면 i보다 
왼쪽에 있는 수들의 오큰수를 찾기 위해 arr[i + 1]을 매번 봐야 하는지 생각해 보세요.
1. 스택에 값을 왼쪽부터 넣는다. 
2. for(i=0; i<N; i++)
for문 안에 
while(isEmpty()) // 스택이 비었는지. 확인

스택에다가 NGE를 구하지 않은 인덱스를 넣으면 풀 수 있는 문제다.
스택에 오큰수를 구하지 않은 인덱스를 넣으면 풀 수 있는 문제.


스택에 i번째가 stack[top]에 올 수 있도록 push 비교할때 POP()을 해주고 
이 일련의 작업이 끝나면 스택을 한번 비워준 뒤 
다시 i+1번째가 stack[top]에 올 수 있도록 push를 해줬는데. 

배열을 두 개 만들고
하나의 배열에 우선 테스트케이스 수 만큼 입력을 받은 뒤
하나의 배열로 


스택에다가 NGE를 구하지 않은 인덱스를 넣으면 풀 수 있는 문제다.
말하신게 
예시로 수열길이 4 => 3 5 2 7 예제라고 가정했을때
3의 오큰수를 입력 배열 말고 다른 배열에 저장하고.
5 2 7 을 스택에 올리고
5 2 7 을 
4 => 3 5 2 7 
3의 오큰수를 찾았어
남은 5 2 7 을 push해
5의 오큰수를 찾았어
2 7 을 push해
2의 오큰수를 찾았어
7을 push해?

