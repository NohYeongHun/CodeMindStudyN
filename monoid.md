# 잘모르는 정의?
프레임워크 : 라이브러리와 클래스가 합쳐진형태가 일반적이고 
앱 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합.
앱을 구축할 때 모든 앱의 공통적인 부분을 제공해줌.
lambda calculus = 람다 미적분
Recursive descent parser = 재귀 하향 파서
Pure languages = 순수 언어
Pure function = side-effect가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수.
따라서 순수함수는 스레드가 안전하고 병렬적인 계산이 가능하다.
ex) y=f(x)*f(x)
Impure languages = 불순한 언어

# 순수 함수형 언어의 이점
모든 데이터 흐름이 명시적이다. 추론하기 쉽다. 모듈화와 관련해서 명시적이 데이터 흐름은 모듈화를 쉽게 한다.

# 모나드의 간단 정의
어떤 타입 M에 대해 아래의 두 함수, pure과 compose가 존재할 때, M은 모나드입니다.
모나드는 연산을 정의하고 추상화 하기 위해 쓰이는 것
제네릭 프로그래밍은 여러 데이터들에 대해 일반적인, 즉 유연한 코드를 작성함으로서 재사용성을 끌어올림.
즉 모나드는 '합칠 수 있는 연산'을 정의하고 추상화 하기 위해 사용한다.
'어떤 연산이 모나드로 정의된다면, 그 연산에 해당하는 모든 프로그램은 합쳐질 수 있다.'
ex) 입출력 연산 

# 모나드 사용 이유
프로그래밍 적으로 다음 세 가지를 충족시 모나드 라고 부를 수 있다.
1. 타입을 인자로 받는 타입이다.
2. unit(return) operator가 있어야 한다.
3. bind operator가 있어야 한다.

# code
```
val maybeValue: Maybe<Int> = Maybe.just(14)//(1)
maybeValue.subscribeBy(//(2)
  onComplete = {println("Completed Empty")},
  onError = {println("Error $it")},
  onSuccess = { println("Completed with value $it")}
)
val maybeEmpty:Maybe<Int> = Maybe.empty()//(3)
maybeEmpty.subscribeBy(//(4)
  onComplete = {println("Completed Empty")},
  onError = {println("Error $it")},
  onSuccess = { println("Completed with value $it")}
)
모나드인 Maybe는 값을 포함할 수도, 포함하지 않을수도 있는 타입이며, 
방출된 결과 값, 혹은 오류에 상관없이 완료가 됩니다. 
Maybe는 총 세가지의 터미널 메서드를 가지고 있는데, 오류가 발생 시 onError 함수가 
호출이 되어 이에 대한 구현 처리를 하게됩니다. 
또는 성공시에는 onSucess 함수가 호출이되어 성공에 대한 구현 처리를 하게됩니다. 
값도 없고, 오류도 없는 경우엔 최종적으로 완료하여 onComplete 함수를 호출하게 됩니다.
```


# 함수형 프로그래밍을 위한 모나드 소개
함수형 프로그래밍 커뮤니티는 보통 두개의 진영으로 나뉘는데 Miranda0 및
Haskell과 같은 순수 언어(Pure languages)는 순수하고 단순한 람다 미적분임.
Scheme 및 Standard ML과 같은 불순한 언어(Impure languages)는 람다 미적분을 증가시킴.
순수한 언어는 추론하기가 더 쉽고 게으른 것의 이점을 얻을 수 있다.
불순한 언어는 효율성 이점을 제공하고 때로는 보다 간결한 표현 방식이 가능함.
순수한 기능적 언어에 불순한 효과를 통합하기 위해 모나드, 범주 이론에서 비롯된
모나드 개념이 적용되었다.
모나드의 응용은 세가지 사례 연구와 함께 설명될 것이고, 섹션 2에서는 모나드를 사용하여
간단한 수정하기 쉽도록 평가자. 섹션 3은 다음에 의해 충족되는 법률을 설명한다.
섹션 1: 세가지 사례 연구 설명
섹션 2: 모나드를 사용하여 간단히 수정하기 쉽도록함
섹션 3: 담음에 의해 충족되는 법률 설명
섹션 4: 모나드가 순수한 기능 언어로 업데이트 가능한 상태를 제공하는 이전문제에 대한 새로운 솔루션 제공
섹션 5: 재귀 하향 파서(Recursive descent parser) 구축 문제에 대한 모나드; 관심의대상
출연자 : J.Jeuring 및 E.Meijer, 편집자, 고급 기능 프로그램

# 모나드의 평가
순수 함수형 언어에는 다음과 같은 이점이 있습니다. 모든 데이터 흐름이 명시 적으로 만들어집니다.
그리고이 단점 : 때로는 고통스럽게 명시 적입니다.
순수 함수 언어로 된 프로그램은 일련의 방정식으로 작성됩니다.
명시 적 데이터 흐름은 표현식의 값이
자유 변수. 따라서 같음을 같음으로 대체하는 것은 항상 유효합니다.
이러한 프로그램은 특히 추론하기 쉽습니다. 명시 적 데이터 흐름은 또한
계산 순서가 무관하여 이러한 프로그램을 취약하게 만듭니다.
게으른 평가.
모듈화와 관련하여 명시적인 데이터 흐름이 모두 축복이됩니다.
그리고 단점. 한편으로는 궁극적 인 모듈성입니다. 모든 데이터
출력되는 모든 데이터는 매니페스트로 렌더링되고 액세스 가능하며
적응성. 다른 한편으로는 모듈성의 최저점입니다. 의 본질
알고리즘은 데이터를 전달하는 데 필요한 배관 아래에 묻힐 수 있습니다.
생성 지점을 사용 지점까지.
순수한 기능적 언어로 평가자를 작성한다고 가정 해 보겠습니다.
– 오류 처리를 추가하려면 각 재귀 호출을 수정하여 확인해야합니다.
오류를 적절히 처리하고 처리합니다. 내가 불순한 언어를 사용 했더라면
예외, 그러한 구조 조정이 필요하지 않습니다.
– 수행 된 작업 수를 추가하려면 각 재귀를 수정해야합니다.
이러한 카운트를 적절하게 전달하도록 호출하십시오. 불순한 언어를 사용 했나요
증분 될 수있는 전역 변수를 사용하면 그러한 재구성은
필요합니다.
– 실행 추적을 추가하려면 각 재귀 호출을 다음과 같이 수정해야합니다.
그러한 흔적을 적절하게 통과하십시오. 불순한 언어를 사용 했더라면
부작용으로 출력을 수행하면 그러한 구조 조정이 필요하지 않습니다.
또는 모나드를 사용할 수 있습니다.
이 노트는 모나드를 사용하여 평가자를 구성하는 방법을 보여줍니다.
위에서 언급 한 변경은 간단합니다. 각각의 경우에 필요한 모든 것
모나드를 재정의하고 몇 가지 로컬 변경을 수행하는 것입니다.
이 프로그래밍 스타일은 다양한
불순한 언어의 특징. 해당 사항이없는 경우에도 적용될 수 있습니다.
불순한 특징. 제공되는 유연성 사이의 긴장을 제거하지 않습니다.
명시 적 데이터 및 암시 적 배관에 의해 제공되는 간결성; 그러나 그것은 어느 정도 그것을 개선합니다.
이 기술은 평가자뿐만 아7니라 다양한 기능에 적용됩니다.
프로그램들. 수년 동안 Glasgow는
기능적 언어 Haskell을위한 컴파일러. 컴파일러 자체는
Haskell이며 여기에 설명 된 구조화 기법을 사용합니다. 이 종이
프로그램에서 모나드를 사용하는 방법을 수십 줄로 설명합니다. 경험이 있습니다.
3 배 더 큰 프로그램에서 사용하는 것입니다.
간단한 용어에 대한 기본 평가자로 시작한 다음 변형을 고려합니다.
예외, 상태 및 출력을 모방합니다. 공통점을 분석하고
그리고 이것들로부터 모나드의 개념을 추상화합니다. 그런 다음 각각의
변형은 모나 딕 프레임 워크에 적합합니다.

# 변형 0 : 기본평가자 
평가자는 설명을 위해 취해진 용어에 따라 행동합니다.
지나치게 단순합니다.
data term = Con Int | Div Term Term
항은 상수 Con a (여기서 a는 정수)이거나 몫인 Div t u입니다.
여기서 t와 u는 항입니다.
기본 평가자는 단순성 그 자체입니다.
eval :: Term → Int
eval (Con a) = a
eval (Div t u) = eval t ÷ eval u
eval 함수는 항을 정수로 취합니다. 항이 상수이면
상수가 반환됩니다. 용어가 몫이면 하위 용어가 평가되고
계산 된 몫. 정수 나눗셈을 나타 내기 위해‘÷’를 사용합니다.
다음은 실행 예제를 제공합니다.
answer, error :: term
answer = (Div (Div (Con 1972) (Con 2)) (Con 23))
error = (Div (Con 1) (Con 0))
eval 답을 계산하면 ((1972 ÷ 2) ÷ 23)의 값인 42가 산출됩니다. 그만큼
기본 평가자는 오류 처리를 통합하지 않으므로 평가 오류의 결과
정의되지 않았습니다.

# 변형 1 : Exception
위의 두 번째 예가 반환되도록 오류 검사를 추가하고 싶다고 가정합니다.
현명한 오류 메시지. 불순한 언어로 이것은 쉽게 얻을 수 있습니다.
예외 사용.
순수한 언어에서 예외 처리는 다음을 도입하여 모방 될 수 있습니다.
예외를 발생시킬 수있는 계산을 나타내는 유형
data M a = Raise Exception | Return a
type Exception = String

유형 M a의 값은 Raise e 형식을 갖습니다. 여기서 e는 예외입니다.
a를 반환합니다. 여기서 a는 a 유형의 값입니다. 관례 상 a는
M a에서와 같이 유형 변수 및 해당 유형의 값에 이르는 변수로
반환 a.
( '데이터'와 '유형'선언의 차이점에 대한 단어. '데이터'
선언은 새로운 데이터 유형 (이 경우 M)을 도입하고
해당 유형의 값,이 경우에는 Raise 및 Return. '유형'선언은
기존 유형의 새 이름 (이 경우 Exception이 다른 이름이 됨)
문자열.)
평가자를이 표현에 적용하는 것은 간단하지만 지루합니다.

# reference
<br>
[간단한 모나드설명]https://black7375.tistory.com/69
<br>
[3분 모나드]https://overcurried.com/3%EB%B6%84%20%EB%AA%A8%EB%82%98%EB%93%9C/