# 문자열 C++
```
- getline() : 공백 문자가 포함되어 있는 문장을 입력받고
  그대로 출력가능
- cin.ignore(256,".") : //256자 아니면 "."을 통해 입력구분
  입력받을 때 특정 문자를 이용해서 구분함.
  ex) 2013(a).13(b).13(c)
- cout.width() : 출력되는 자리수 결정.
- cout.precision(index): index자릿수 만큼으로 조절 
  ex) cout.precision(5); cout<<12345.66; => 12345

ex)cout.width(4) // 4자리수 결정.
- cout.fill('0') : 자리수에서 빠진 만큼 0으로 채워줌.
- cout<<fixed : 소수점 아래 값을 고정하는 표현
즉 cout<<fixed 이후에 cout.precision(6)을 입력하면 소숫점 아래를 6자리로 고정함.
```

# 8진수, 16진수 표기
int i;
- 10진수 표기 printf("%d",i);
- 8진수 표기 printf("%o",i);
  C언어에서 소스 코드 작성 시 0으로 시작하는 수는 8진수로 인식된다. int a = 013; // 10진수 11과 같은 값
- 16진수 표기 printf("%x",i); // 소문자로 출력
- 16진수 표기 printf("%X",i); // 대문자로 출력

# ASCII 코드
```
  #include <iostream>
  using namespace std;
  //문자를 정수로 (ASCII코드 변환)
  int main(){
      char n;
      scanf("%s",&n);
      printf("%d",n);
  }
  #include <iostream>
  using namespace std;

  int main(){
      int n;
      scanf("%d",&n);
      printf("%c",n);
  }
```

# 증감 연산자
  어떤 변수(a)에 값을 저장한 후 a+1 의 값을 출력할 수도 있고,
  ++a 연산을 한 후에 출력할 수도 있다.

  ++a, --a, a++, a-- 와 같이 어떤 변수의 앞이나 뒤에 붙여
  변수에 저장되어있는 값을 1만큼 더하거나 빼주는 연산자를 증감연산자라고 한다.
  a2 = ++a // a의 값을 1을 증가시키고 할당시킴.
  a2 = a++ // a의 값을 a2에 할당한 뒤에 a의 값을 1 증가시킴
  ex) return a++ // a를 리턴하고 a에 1을 더한다.
  증감연산자를 변수 앞에 붙이면 그 변수를 사용하기 전에 증감을 먼저 수행하고,
  증감연산자를 변수 뒤에 붙이면 동작 후에 나중에 증감을 수행한다.

# 비교/관계 연산자 
  어떤 값을 비교하기 위해 비교/관계 연산자 사용 가능.
  비교/관계연산자는 주어진 2개 값을 비교 
  그 결과가 참인 경우 참을 나타내는 정수값 1로 계산
  거짓인 경우 거짓을 나타내는 정수값 0으로 계산.
  - ==,&&,>=,<=,||, (x&&!y)||(!a&&b)
  - == 비교 연산
  ex) int a=3, b=4; 
  b>a ==1// why? b>a (true) 참일 경우 정수형 1 리턴
  a<=b ==0 // why? a<=b(false) 거짓일경우 정수형 0리턴
  - && AND 연산
  ex) a&&b == 0 // why? a!=b (false) 이므로 정수형 0 리턴
      만약 a==b라면 a&&b ==1 //a ==b(true)이므로 정수형 1리턴
  - <= 비교 관계연산
  ex) a<=b ==1 // b>=a (true)
  
  - || OR연산
  ex) a||b ==1 // b,a둘중 하나라도 참이면 1 리턴.
  만약 a=0,b=0 이라면 // a||b ==0;

  - (x&&!y)||(!a&&b) XOR연산
  합집합에서 교집합을 뺀 것을 의미.



# cin , printf ??
```
  printf("%d",a&&b); // a&&b가 참이면 1 거짓이면 0을 출력한다.
  cin << a&&b // 정상적인 값이 출력이 안됨. // 연산자 우선순위
  c= a&&b; // 
  cin <<c; // 이렇게 두식으로 나누어 줘야됨.
```

# 비트 단위 연산자
- 1이 입력되었을 때 저장되는 1을 32비트 2진수로 표현시
  00000000 00000000 00000000 00000001 이고,
  ~1은 11111111 11111111 11111111 11111110 가 되는데 이는 -2를 의미한다.
  컴퓨터 저장되는 모든 데이터들은 2진수 형태로 바뀌어 저장되낟.
  0과 1로만 구성되는 비트단위들로 변환되어 저장.
  양의 정수는 2진수 형태로 바뀌어 저장되고, 음의 정수는 "2의 보수 표현" 방법으로 저장됨. int형 으로 선언된 변수에 양의 정수 5를 저장 시 5의 2진수 형태인 101이 32비트로 만들어져 저장됨.
  int 형의 정수 0 은
  00000000 00000000 00000000 00000000

  그리고 -1은 0에서 1을 더 빼고 32비트만 표시하는 형태로
  11111111 11111111 11111111 11111111 로 저장된다.

  -2는 -1에서 1을 더 빼면 된다.
  11111111 11111111 11111111 11111110 로 저장된다.

  그래서 int 형으로 선언된 변수에는 최소 -2147483648 을 의미하는
  10000000 00000000 00000000 00000000 부터

  최대 +2147483647 을 의미하는
  01111111 11111111 11111111 11111111 로 저장될 수 있는 것이다.

  그렇다면 -2147483648
  10000000 00000000 00000000 00000000 에서 1을 더 뺀다면?

  01111111 11111111 11111111 11111111 이 된다.
  즉 -2147483649 가 아닌 +2147483647 이 되는 것이다.

  이러한 것을 오버플로우(overflow, 넘침)라고 한다.

  이러한 내용을 간단히 표시하면, 정수 n이라고 할 때,

  ~n = -n - 1
  -n = ~n + 1 과 같은 관계로 표현된다.

  이 관계를 그림으로 그려보면 마치 원형으로 수들이
  상대적으로 배치된 것과 같다.

- 비트 단위 연산자 : &(and)
  비트 단위 and 연산은 두 비트열이 주어졌을 때,
  둘 다 1인 부분의 자리만 1로 만들어주는 것과 같다.

- 비트 단위 연산자 : |(or)
  비트단위 or 연산은 두 비트열이 주어졌을 때,
  둘 중 하나라도 1이면 1로 만들어 주는 것과 같다.

- 비트 단위 연산자 : ^(xor)
  비트 단위 xor연산.

# 삼항 연산
  - 3항 연산자 ?
  "조건식 ? (참인 값):(거짓인 값)"의 형태로 사용하는 연산자.
  조건식의 계산결과가 참인 경우에는 ':' 왼쪽 값 또는 식으로 바뀌고,
  거짓인 경우에는 ':' 오른족의 값 또는 식으로 바뀐다.
  ex) 123>456? 0 : 1 // 123>456 의 비교연산 결과가 거짓이므로 
  1이 됨.

# 연산자 우선순위
- reference :
[연산자우선순위] https://dojang.io/mod/page/view.php?id=188
  ex) (a>b ? a:b)>c ? (a>b ? a:b):c 의 계산식은
  a, b, c 의 값 중 가장 큰 값으로 계산된다.
  실무에서는 연산자의 계산 순서를 ( ) (괄호)로 명확하게 나타내는 것을 선호합니다.

  # 16진수 표기
  - int decimal = 41; //10진수
  - int octal = 041; // 8진수
  - int hexadecimal = 0x41; // 16진수
  - 8진수는 숫자앞에 0(숫자0)을 붙여줌. 16진수는 숫자압에 0x(숫자0)을 붙여줌.
  - 출력시 16진수로 출력하고싶으면 출력할 값 앞에 hex를 붙여줌
  - 출력시 8진수로 출력하고 싶으면 출력할 값 앞에 oct를 붙여줌.
  - cout.setf(ios::uppercase);
    cout.setf(ios::hex, ios::basefield);
    대문자, 16진수 출력을 위한 cout 설정
  
  # continue
  - 반복문 안에서 continue;가 실행되면 아래의 내용을 건너뛰고, 다음 반복을 수행함.
  즉, 다음 반복으로 넘어가는 것.


# 문자열 자르기
- C언어 또는 C++에서 문자열은 \0으로 종료가 되게 되어있습니다.       
  그렇기에 인자로 받은 문자열에서 구분자가 있는 위치를 널 포인트로 치환해줌으로써, 문자열을 끊기게 만듭니다. 예를 들어 공백을 구분자로 뒀을 경우 위와 같은 방식으로 문자열이 잘리게 됩니다.

- C/C++에서 자신이 원하는 문자열을 잘라낼 때 사용하는 함수로       
  strtok라는 함수가 있다. 인자 값으로 전달받은  매개변수를 구분자로 하여 문자열을 잘라내어 return 함. 만약 더 이상 자를 문자열이 없다면 NULL을 반환.

# strtok 함수 => char *strtok(char *str, const char *delimiters);
- str : 자르고자 하는 문자열
- delimiters : 자를 기준을 정하는 구분자.
ex)
```c++
#include <iostream>
#include <string.h> //strtok 함수가 선언된 헤더 파일
//#include <cstring> //C++일 경우

int main() {
    char str[] = "MY NAME IS TOM"; //대상 문자열 
    char *temp = strtok(str," "); //공백을 기준으로 문자열 자르기
    
    while (temp != NULL) { //널이 아닐때까지 반복
        cout<<temp; // 출력
        temp = strtok(NULL, " ");	//널문자를 기준으로 다시 자르기
    }
	
    return 0;
}
/* 더 이상 자를 수가 없으면 NULL값을 리턴하므로 NULL값이 리턴될 때  
   까지 반복하여 문자열을 자르는 방식 */   
```
---------
```c++
  #include<iostream>
char* my_strtok(char* str, const char* delimiters){
   static char* pCurrent;
   char* pDelimit;

   if ( str != NULL )pCurrent = str;
   else str = pCurrent;

   if(*pCurrent == NULL) return NULL;

   //문자열 점검
   while (*pCurrent)
   {
       pDelimit = (char*)delimiters ;
       
       while (*pDelimit){
         if(*pCurrent == *pDelimit){
               *pCurrent = NULL;
               ++pCurrent;
               return str;
            }
            ++pDelimit;
       }
       ++pCurrent;
   }
    // 더이상 자를 수 없다면 NULL반환
    return str;
}
```

# c++ 공백자르고 저장.
```c++
int main(){
    string s;
    getline(cin, s);  //s값을 공백을 자르고 저장함.
    
    char * ctemp = new char[s.length()];
    strcpy(ctemp, s.c_str());
    char* cptr = strtok(ctemp, " ");

    int i =0;
    for(; cptr != NULL; i++){
        cptr = strtok(NULL, " ");
    }
    cout<<i<<endl;
}
```