# 해시 정의
해시는 해시 함수로 구현한다. 해시 함수는 마치 배열처럼, 어떤 자료를 찾을 때 O(1)의 시간만을 소요한다. 해시함수에 키 값을 넣어 주소값을 얻고, 그 주소에 위치한 버킷에 저장된 데이터를 가져오는 방식을 사용한다. 하지만, 언제나 O(1)이 보장되는 것은 아니다.<br>
자세한 것은 해시 테이블 참고.<br>
파이썬의 해시는 “딕셔너리”(Dictionary)라고 부른다.<br>
앤트리, 자바 해시맵
dict1 = {1:"하나", "apple":"사과", "리스트":[1, 2, 3]}

# 해시 테이블 구성.
<u>**키, 해시함수, 해시, 값, 저장소로 이루어짐.**</u>
시간복잡도는 O(1)이다.
하지만, 해시 충돌로 인해 최악의 경우 O(n)이 될 수 있음. 

- 삭제 :
저장되어 있는 값을 삭제할 때는 저장소에서 해당 key와 매칭되는 값(value)를 찾아서 삭제하면 된다.

- 검색 :
키로 값을 찾아내는 과정은 Deletion 과정과 비슷. 
키로 hash를 구함. -> hash로 값을 찾는다.

# 해시 충돌

- 해시 충돌:
해시를 이용한 자료구조 방식에 필연적으로 나타낼 수 있는 문제는,
무한한 값(KEY를 의미)을 유한한 값(Hash의미)으로 표현하면서 서로 다른
두 개 이상의 유한한 값이 동일한 출력값을 가지게 된다는 것.
John과 Sandra의 hash가 같음. 이런 현상을 hash collision이라고 함.
Hash collision은 필연적으로 나타나는 현상.
- ex) n+1개의 비둘기가 n개의 비둘기 집에 들어간다면 적어도 1개 이상의
  비둘기 집에 2마리 이상의 비둘기가 있을 것.

# 해시충돌 해결방법 1. Separate Chaining 
체이닝(Chaining)은 자료 저장 시, 저장소(bucket)에서 충돌이 일어나면 해당 값을 기존 값과 연결시키는 기법이다.
이 때 연결리스트(Linked List) 자료구조를 이용한다. 다음에 저장된 자료를 기존의 자료 다음에 위치시키는 것이다.

- ex) John과 Sandra 동일한 hash 값 '152' 를 갖는다.
  John의 entries에 Sandra의 entries를 연결리스트 방식으로 연결
  John Smith -> Sandra Dee

# Chaining의 장단점
- Chaining 장점 :
1) 한정된 저장소(Bucket)을 효율적으로 사용할 수 있다.
2) 해시 함수(Hash Function)을 선택하는 중요성이 상대적으로 적다.
3) 상대적으로 적은 메모리를 사용한다. 미리 공간을 잡아 놓을 필요가
   없다.<br>
   
- Chaining 단점 :
1) 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율을 낮출
   수 있다.
2) 외부 저장 공간을 사용한다.
3) 외부 저장 공간 작업을 추가로 해야 한다.

- Chaining 시간 복잡도(Big-O)
복잡도를 계산하기 전, 한 가지를 추가하자면 해시 테이블의 저장소(Bucket)의 길이를 ‘n’, 키(key)의 수를 ‘m’이라고 가정했을 때, 평균적으로 저장소에서 1개의 hash당 (m/n)개의 키가 들어있다. 이를 ‘α’라고 정의한다.
m/n = α (1개의 Hash당 평균적으로 α개)

# Chaining Insertion & Deletion & Search
- Insertion :
  충돌이 일어났을 때, 해당 해시(Hash)가 가진 연결리스트의 Head에 자료를 저장할 경우, O(1)의 시간복잡도를 가진다. 해당 해시(Hash)를 산출하고 저장하면서 기존 값(value)를 연결하는 행위만 하면 되기 때문이다.<br>

  반면 Tail에 자료를 저장할 경우, O(α)의 시간 복잡도를 가진다. 해당 해시(Hash)를 저장할 때 모든 연결리스트를 지나서 Tail에 접근해야 하기 때문이다. 최악의 경우, O(n)의 시간 복잡도를 가진다. 한 개의 해시(Hash)에 모든 자료가 연결되어 있을 수 있기 때문이다.

- Deletion & Search :
  삭제와 검색은 시간 복잡도 측면에서 비슷한 개념을 공유한다. 산출된 Hash의 연결리스트를 차례로 살펴보아야 하므로 O(α)의 시간 복잡도를 가진다. 최악의 경우 O(n)의 시간복잡도를 가진다. 한 개의 해시(Hash)에 모든 자료가 연결되어 있을 수 있기 때문이다. 이 경우 모든 자료를 다 살펴보아야 한다.

# 해시충돌 해결방법 2. Open Addressing(개방 주소법)

  개방주소법은 데이터의 해시(hash)가 변경되지 않았던 chaining과는 달리 비어있는 해시(hash)를 찾아 데이터를 저장하는 기법이다. 따라서 개방주소법에서의 해시테이블은 1개의 해시와 1개의 값(value)가 매칭되어 있는 형태로 유지된다.

  위의 그림을 보면, Sandra가 저장될때 해시가 John으로 채워져 있어서 그 다음 Hash에 Sandra를 저장했다. 그리고 Ted의 해시도 Sandra가 저장되어 있으므로 그 다음 해시에 Ted를 저장했다. 이처럼 비어있는 해시를 찾아 저장하는 방법을 Open Addressing라고 한다.

  이 때, 비어있는 해시(Hash)를 찾는 과정은 동일해야 한다.(일정한 규칙을 따라 찾아가야 한다.)

  Open Addressing는 위에서 언급한 비어있는 해시를 찾는 규칙에 따라 다음과 같이 구분할 수 있다.

- 선형 탐색(Linear Probing): 다음 해시(+1)나 n개(+n)를 건너뛰어   
  비어있는 해시에 데이터를 저장한다.
- 제곱 탐색(Quadratic Probing): 충돌이 일어난 해시의 제곱을 한 
  해시에 데이터를 저장한다.
- 이중 해시(Double Hashing): 다른 해시함수를 한 번 더 적용한 해시에 
  데이터를 저장한다.

# Open Addressing 장단점
- 장점 :
  1) 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.
  2) 또 다른 저장공간에서의 추가적인 작업이 없다.
- 단점 :
  1) 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지된다.
  2) 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다.

# Open Addressing 시간 복잡도 (Big-O)
- 장점 :
  1) 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.
  2) 또 다른 저장공간에서의 추가적인 작업이 없다.
- 단점 :
  1) 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지된다.
  2) 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다.

# Open Addressing Insertion & Deletion & Search
  삽입, 삭제, 검색 모두 대상이 되는 Hash를 찾아가는 과정에 따라 시간복잡도가 계산이 된다. 해시함수를 통해 얻은 Hash가 비어있지 않으면 다음 버킷을 찾아가야 한다. 이 찾아가는 횟수가 많아지면 많아질 수록 시간복잡도가 증가한다. 최상의 경우 O(1) ~ 최악의 경우 (O(n)).

  따라서 Open Addressing에서는 비어있는 공간을 확보하는 것(= 저장소가 어느 정도 채워졌을 때 저장소의 사이즈를 늘려주는 것)이 필요하다.

  최악의 경우 저장소를 모두 살펴보아야 하는 경우가 생길 수 있다./O(n)

# Last : Hash Table Data Structure의 단점
- 순서가 있는 배열에는 어울리지 않는다.
  : 상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash Table은 어울리지 않다. 순서와 상관없이 key만을 가지고 hash를 찾아 저장하기 때문이다.
- 공간 효율성이 떨어진다.
  : 데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다. 공간이 부족하거나 아예 채워지지 않은 경우가 생길 가능성이 있다.
- Hash Function의 의존도가 높다.
  : 평균 데이터 처리의 시간복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않는 결과이다. 해시함수가 매우 복잡하다면 해시테이블의 모든 연산의 시간 효율성은 증가할 것이다.

# 정적 해싱과 동적해싱
- 정적 해싱:
  해싱 테이블의 버킷 개수 고정, 데이터 개수를 이미 알고 있는 경우.
  어떤 키 값 k에 대해 h(k)는 0~(b-1)사이의 정수 // (b:버킷개수)
  특징 : 해시충돌, 버킷부족, 해시 테이블, 함수 주기적 변경 필요.

- 동적 해싱:
  버킷 개수가 가변적, 데이터 등감에 원활하게 대응하기 위하여 사용.
  해시 테이블 대신에 트라이 자료 구조를 이용.
  특징 : 동적으로 메모리 크기 변화.
  트리 구조 인덱스 생성.

- 확장 해싱:
  인덱스 구조 조절. 해시 함수의 동적 변경 허용 기술
  디렉터리와 버킷으로 구성된 2단계 구조
  해시 함수의 동적 변경 허용.

# reference
[hash함수]https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o


# 안녕
