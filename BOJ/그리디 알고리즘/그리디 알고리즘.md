# 그리디 알고리즘.
- 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식.
- 동적 프로그래밍과 그리디 프로그래밍은 상호 보완적인 관계.
- 예시로 가장 큰수를 탐색할 때 그리디 알고리즘을 사용한다면 최고 큰 수를 찾지 못하는 경우도 있음.
- 활동 선택 문제
한 강의실에서 여러 개의 수업을 하려고 할 때 한 번에 가장 많은 수업을 할 수 있는 경우 고르기.

# Greedy의 조건
- 탐욕스러운 선택 조건<br>
앞의 선택이 이후의 선택에 영향을 주지 않는 조건
- 최적 부분 구조 조건<br>
문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적 문제 해결방법이라는 조건.
# Ex(예시)
```c++
ex) i ={1, 2, 3, 4, 5, 6, 7, 8, 9}
s(i) ={ 1, 2, 4, 1, 5, 8, 9, 11, 13} 시작 시간
f(i) ={3, 5, 7, 8, 9, 10, 11, 14 ,16} 끝 시간

- 활동 선택문제

A1과 A4는 동시에 선택할 수 없음. WHY? 시작시간이 같고 시작시간과 끝시간 사이에 강의시간이 곂치기 때문
A1,A3,A6,A8 / A1,A3,A7,A9 한 강의실에서 여러개 수업 시 가장 많은 수업 시키기.
동적 프로그래밍으로도 풀 수 있음. 
예시로 G18을 A1이 종료된 후부터 A8 시작 전 활동의 집합이라고 보면 G18={A3,A5,A6,A7}임. 
이 중에서 최적의 조합 (활동들이 겹치지 않고 개수는 최대)B18이라고 하면, 하나의 예로 B18={A3, A6}

{ A3, A7 }
그리디 알고리즘으로 더 효율적으로 풀 수 있음.
직관적으로 생각시 최적의 해를 구하기 위해서는 첫 번째 활동이 최대한 일찍 끝나면 됨. 그래야 다른
활동들을 더 많이 선택할 수 있기 때문. 위의 경우에서는 첫 선택으로 가장 빨리 끝나는 A1을 골라야겠죠. A1을 골랐다면 이제 A2와 A4는 고를 수 없습니다(A1이랑 겹침). 그 다음 선택은 다음으로 일찍 끝나는 A3가 될 겁니다. 그 다음은 A6, 마지막은 A8이 되어 최종적으로 {A1, A3, A6, A8}이 됩니다.

- 분할 가능 배낭 문제

지난 시간 동적 프로그래밍에서는 무게에 따라 물건을 넣거나 넣지 못하는 배낭 문제(0/1 배낭 문제)를 풀었습니다. 하지만 이번 시간의 배낭 문제는, 같은 배낭 문제이지만 물건이 무거울 경우 쪼개서 넣을 수 있습니다. 즉 무게가 초과할 거 같은면 물건을 쪼개서 일부만 넣을 수 있다는 것이죠.

지난 시난 시간에는 동적 프로그래밍으로 복잡하게 풀었다면, 이번에는 그리디 알고리즘으로 간단하게 풀 수 있습니다. 직관적으로 생각해봅시다. 물건을 쪼갤 수 있다는 가정 하에서는 무엇부터 넣는 게 최선일까요? 무게 대비 가치가 높은 것들을 먼저 넣는 게 좋겠죠?
```
